##一：AbstractQueuedSynchronizer的共享模式，CountDownLatch使用的就是共享模式
```java
public abstract class AbstractQueuedSynchronizer
        extends AbstractOwnableSynchronizer
        implements java.io.Serializable {

   /**
    * Attempts to acquire in shared mode. This method should query if
    * the state of the object permits it to be acquired in the shared
    * mode, and if so to acquire it.
    * 尝试在共享模式下获取。此方法应查询对象的状态是否允许在共享模式下获取该对象，
    * 以及是否允许获取该对象。
    *
    * <p>This method is always invoked by the thread performing
    * acquire.  If this method reports failure, the acquire method
    * may queue the thread, if it is not already queued, until it is
    * signalled by a release from some other thread.
    * 执行获取的线程始终调用该方法。如果该方法报告失败，则acquire方法可能将线程排队(如果尚未排队),
    * 世道其它线程发出释放信号。
    *
    * <p>The default implementation throws {@link
    * UnsupportedOperationException}.
    *
    * @param arg the acquire argument. This value is always the one
    *        passed to an acquire method, or is the value saved on entry
    *        to a condition wait.  The value is otherwise uninterpreted
    *        and can represent anything you like.
    * @return a negative value on failure; zero if acquisition in shared
    *         mode succeeded but no subsequent shared-mode acquire can
    *         succeed; and a positive value if acquisition in shared
    *         mode succeeded and subsequent shared-mode acquires might
    *         also succeed, in which case a subsequent waiting thread
    *         must check availability. (Support for three different
    *         return values enables this method to be used in contexts
    *         where acquires only sometimes act exclusively.)  Upon
    *         success, this object has been acquired.
    *         负值表示失败；0表示再共享模式下获取成功，但后续共享模式获取无法成功；
    *         如果共享模式下的获取成功，则为正值，随后的共享模式获取也可能成功，在这种情况下，后续等待线程必须检查可用性。
    *         （对三个不同返回值的支持使此方法能够在获取有时仅起独占作用的上下文中使用。）
    *         成功后，已获取此对象。
    * @throws IllegalMonitorStateException if acquiring would place this
    *         synchronizer in an illegal state. This exception must be
    *         thrown in a consistent fashion for synchronization to work
    *         correctly.
    * @throws UnsupportedOperationException if shared mode is not supported
    */
   protected int tryAcquireShared(int arg) {
      throw new UnsupportedOperationException();
   }

   /**
    * Acquires in shared mode, ignoring interrupts.  Implemented by
    * first invoking at least once {@link #tryAcquireShared},
    * returning on success.  Otherwise the thread is queued, possibly
    * repeatedly blocking and unblocking, invoking {@link
    * #tryAcquireShared} until success.
    * 共享模式下获取，或略中断。通过至少调用一次 tryAcquireShared来实现，
    * 并在成功时返回。否则想成将排队，可能会重复阻塞和取消阻塞，只到调用tryAcquireShared成功。
    * 整体逻辑和acquire差不多，acquire调用的是tryAcquire
    *
    * @param arg the acquire argument.  This value is conveyed to
    *        {@link #tryAcquireShared} but is otherwise uninterpreted
    *        and can represent anything you like.
    */
   public final void acquireShared(int arg) {
      if (tryAcquireShared(arg) < 0)
         doAcquireShared(arg);
   }

   /**
    * Acquires in shared uninterruptible mode.
    * 在共享、不可中断的模式下获取。
    * @param arg the acquire argument
    */
   private void doAcquireShared(int arg) {
      final Node node = addWaiter(Node.SHARED);//初始化一个Node,这里使用的是SHARED
      boolean failed = true;
      try {
         boolean interrupted = false;
         for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                //如果该节点的前置节点是head
               int r = tryAcquireShared(arg);
               if (r >= 0) {
                  setHeadAndPropagate(node, r);
                  p.next = null; // help GC
                  if (interrupted)
                     selfInterrupt();
                  failed = false;
                  return;
               }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
               interrupted = true;
         }
      } finally {
         if (failed)
            cancelAcquire(node);
      }
   }

   /**
    * Sets head of queue, and checks if successor may be waiting
    * in shared mode, if so propagating if either propagate > 0 or
    * PROPAGATE status was set.
    * 设置队列头，并检查后继队列是否在共享模式下等待，如果是，
    * 则在“propagate>0”或“PROPAGATE状态”已设置的情况下进行传播。
    *
    * @param node the node
    * @param propagate the return value from a tryAcquireShared
    */
   private void setHeadAndPropagate(Node node, int propagate) {
      Node h = head; // Record old head for check below
      setHead(node);
      /*
       * Try to signal next queued node if:
       *   Propagation was indicated by caller,
       *     or was recorded (as h.waitStatus either before
       *     or after setHead) by a previous operation
       *     (note: this uses sign-check of waitStatus because
       *      PROPAGATE status may transition to SIGNAL.)
       * and
       *   The next node is waiting in shared mode,
       *     or we don't know, because it appears null
       * 如果有一下的情况，尝试向下一个排队的节点发送信号：
       *    调用者显示要传播，
       *        或 
       *
       * The conservatism in both of these checks may cause
       * unnecessary wake-ups, but only when there are multiple
       * racing acquires/releases, so most need signals now or soon
       * anyway.
       */
      if (propagate > 0 || h == null || h.waitStatus < 0 ||
              (h = head) == null || h.waitStatus < 0) {
         Node s = node.next;
         if (s == null || s.isShared())
            doReleaseShared();
      }
   }
}
```